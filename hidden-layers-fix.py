# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mlYHq4m4mqRZxSBICAnrTLdLx9vFKCfk
"""

"""
References:
    - http://neuralnetworksanddeeplearning.com/chap2.html (Backpropagation)
    - https://en.wikipedia.org/wiki/Sigmoid_function (Sigmoid activation function)
    - https://en.wikipedia.org/wiki/Feedforward_neural_network (Feedforward)
"""

import numpy as np

def sigmoid(value: np.ndarray) -> np.ndarray:
    return 1 / (1 + np.exp(-value))

def sigmoid_derivative(value: np.ndarray) -> np.ndarray:
    return value * (1 - value)

class TwoHiddenLayerNeuralNetwork:
    def __init__(self, input_array: np.ndarray, output_array: np.ndarray) -> None:
        self.input_array = input_array
        self.output_array = output_array
        self.predicted_output = np.zeros(output_array.shape)

        self.input_layer_and_first_hidden_layer_weights = np.random.rand(
            self.input_array.shape[1], 4
        )
        self.first_hidden_layer_and_second_hidden_layer_weights = np.random.rand(4, 3)
        self.second_hidden_layer_and_output_layer_weights = np.random.rand(3, 1)

    def feedforward(self) -> np.ndarray:
        self.layer_between_input_and_first_hidden_layer = sigmoid(
            np.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)
        )
        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(
            np.dot(
                self.layer_between_input_and_first_hidden_layer,
                self.first_hidden_layer_and_second_hidden_layer_weights,
            )
        )
        self.layer_between_second_hidden_layer_and_output = sigmoid(
            np.dot(
                self.layer_between_first_hidden_layer_and_second_hidden_layer,
                self.second_hidden_layer_and_output_layer_weights,
            )
        )

        return self.layer_between_second_hidden_layer_and_output

    def back_propagation(self) -> None:
        error = 2 * (self.output_array - self.predicted_output) * sigmoid_derivative(self.predicted_output)

        updated_second_hidden_layer_and_output_layer_weights = np.dot(
            self.layer_between_first_hidden_layer_and_second_hidden_layer.T, error
        )

        error = np.dot(error, self.second_hidden_layer_and_output_layer_weights.T) * sigmoid_derivative(
            self.layer_between_first_hidden_layer_and_second_hidden_layer
        )
        updated_first_hidden_layer_and_second_hidden_layer_weights = np.dot(
            self.layer_between_input_and_first_hidden_layer.T, error
        )

        error = np.dot(
            error, self.first_hidden_layer_and_second_hidden_layer_weights.T
        ) * sigmoid_derivative(self.layer_between_input_and_first_hidden_layer)
        updated_input_layer_and_first_hidden_layer_weights = np.dot(
            self.input_array.T, error
        )

        self.second_hidden_layer_and_output_layer_weights += updated_second_hidden_layer_and_output_layer_weights
        self.first_hidden_layer_and_second_hidden_layer_weights += updated_first_hidden_layer_and_second_hidden_layer_weights
        self.input_layer_and_first_hidden_layer_weights += updated_input_layer_and_first_hidden_layer_weights

    def train(self, output: np.ndarray, iterations: int, give_loss: bool) -> None:
        for iteration in range(1, iterations + 1):
            self.predicted_output = self.feedforward()
            self.back_propagation()
            if give_loss:
                loss = np.mean(np.square(output - self.predicted_output))
                print(f"Iteration {iteration} Loss: {loss}")

    def predict(self, input_arr: np.ndarray) -> int:
        self.array = input_arr
        self.layer_between_input_and_first_hidden_layer = sigmoid(
            np.dot(self.array, self.input_layer_and_first_hidden_layer_weights)
        )
        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(
            np.dot(
                self.layer_between_input_and_first_hidden_layer,
                self.first_hidden_layer_and_second_hidden_layer_weights,
            )
        )
        self.layer_between_second_hidden_layer_and_output = sigmoid(
            np.dot(
                self.layer_between_first_hidden_layer_and_second_hidden_layer,
                self.second_hidden_layer_and_output_layer_weights,
            )
        )
        return int((self.layer_between_second_hidden_layer_and_output > 0.6)[0])

def example() -> int:
    test_input = np.array(
        [
            [0, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [0, 1, 1],
            [1, 0, 0],
            [1, 0, 1],
            [1, 1, 0],
            [1, 1, 1],
        ],
        dtype=np.float64,
    )

    output = np.array([0, 1, 1, 0, 1, 0, 0, 1], dtype=np.float64)

    neural_network = TwoHiddenLayerNeuralNetwork(input_array=test_input, output_array=output)
    neural_network.train(output=output, iterations=10, give_loss=False)

    return neural_network.predict(np.array([1, 1, 1], dtype=np.float64))

if __name__ == "__main__":
    example()